/*!
 * Dynamsoft JavaScript Library
 * @product Dynamsoft Utility JS Edition
 * @website https://www.dynamsoft.com
 * @copyright Copyright 2024, Dynamsoft Corporation
 * @author Dynamsoft
 * @version 1.4.21
 * @fileoverview Dynamsoft JavaScript Library for Utility
 * More info DU JS: https://www.dynamsoft.com/capture-vision/docs/web/programming/javascript/api-reference/utility/utility-module.html
 */
import{_getNorImageData as t,_saveToFile as e,requestResource as i,getNextTaskID as n,mapTaskCallBack as o,worker as s,autoDiscoveryPaths as a,workerAutoResources as r,compareVersion as l,innerVersions as c,EnumCapturedResultItemType as h}from"dynamsoft-core";const f=async t=>{let e;await new Promise(((i,n)=>{e=new Image,e.onload=()=>i(e),e.onerror=n,e.src=URL.createObjectURL(t)}));const i=document.createElement("canvas"),n=i.getContext("2d");i.width=e.width,i.height=e.height,n.drawImage(e,0,0);return{bytes:Uint8Array.from(n.getImageData(0,0,i.width,i.height).data),width:i.width,height:i.height,stride:4*i.width,format:10}};class p{async saveToFile(i,n,o){if(!i||!n)return null;if("string"!=typeof n)throw new TypeError("FileName must be of type string.");const s=t(i);return e(s,n,o)}async drawOnImage(t,e,a,r=4294901760,l=1,c){let h;if(t instanceof Blob)h=await f(t);else if("string"==typeof t){let e=await i(t,"blob");h=await f(e)}return await new Promise(((t,i)=>{let f=n();o[f]=async e=>{if(e.success)return c&&this.saveToFile(e.image,"test.png",c),t(e.image);{let t=new Error(e.message);return t.stack=e.stack+"\n"+t.stack,i(t)}},s.postMessage({type:"utility_drawOnImage",id:f,body:{dsImage:h,drawingItem:e instanceof Array?e:[e],color:r,thickness:l,type:a}})}))}}const u="undefined"==typeof self,g=(()=>{if(!u&&document.currentScript){let t=document.currentScript.src,e=t.indexOf("?");if(-1!=e)t=t.substring(0,e);else{let e=t.indexOf("#");-1!=e&&(t=t.substring(0,e))}return t.substring(0,t.lastIndexOf("/")+1)}return"./"})(),d=t=>{if(null==t&&(t="./"),u);else{let e=document.createElement("a");e.href=t,t=e.href}return t.endsWith("/")||(t+="/"),t};a.utility={version:"1.4.21",path:g},r.utility={js:!0,wasm:!0};const m="1.4.10";"string"!=typeof a.std&&l(a.std.version,m)<0&&(a.std={version:m,path:d(g+`../../dynamsoft-capture-vision-std@${m}/dist/`)});const y="2.4.20";(!a.dip||"string"!=typeof a.dip&&l(a.dip.version,y)<0)&&(a.dip={version:y,path:d(g+`../../dynamsoft-image-processing@${y}/dist/`)});class x{static getVersion(){return`1.4.21(Worker: ${c.utility&&c.utility.worker||"Not Loaded"}, Wasm: ${c.utility&&c.utility.wasm||"Not Loaded"})`}}function v(t,e,i,n){if("a"===i&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?t!==e||!n:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===i?n:"a"===i?n.call(t):n?n.value:e.get(t)}var E,I,b,T,_;function C(t,e){let i=!0;for(let a=0;a<t.length;a++){const r=(a+1)%t.length;if((n=t[a],o=t[r],s=e,(o.x-n.x)*(s.y-n.y)-(o.y-n.y)*(s.x-n.x))<0){i=!1;break}}var n,o,s;return i}function O(t,e){return Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2)}function R(t,e){const[i,n]=t,o=i.x,s=i.y,a=n.x,r=n.y,l=e.x,c=e.y,h=(a-o)**2+(r-s)**2;if(0===h)return Math.sqrt((l-o)**2+(c-s)**2);const f=((l-o)*(a-o)+(c-s)*(r-s))/h;if(f<0)return Math.sqrt((l-o)**2+(c-s)**2);if(f>1)return Math.sqrt((l-a)**2+(c-r)**2);{const t=o+f*(a-o),e=s+f*(r-s);return Math.sqrt((l-t)**2+(c-e)**2)}}function B(t){const e=[];for(let i=0;i<t.length;i++){const n=t[i],o=t[(i+1)%t.length];e.push([n,o])}return e}function M(t){const[e,i]=t;return{x:(e.x+i.x)/2,y:(e.y+i.y)/2}}function A(t,e){const i=[];for(let n=0;n<4;n++)for(let o=0;o<4;o++){const s=D(t[n],t[(n+1)%4],e[o],e[(o+1)%4]);s&&i.push(s)}t.forEach((t=>{C(e,t)&&i.push(t)})),e.forEach((e=>{C(t,e)&&i.push(e)}));return w(function(t){if(t.length<=1)return t;t.sort(((t,e)=>t.x-e.x||t.y-e.y));const e=t.shift();return t.sort(((t,i)=>Math.atan2(t.y-e.y,t.x-e.x)-Math.atan2(i.y-e.y,i.x-e.x))),[e,...t]}(i))}function D(t,e,i,n){const o=e.x-t.x,s=e.y-t.y,a=n.x-i.x,r=n.y-i.y,l=(-s*(t.x-i.x)+o*(t.y-i.y))/(-a*s+o*r),c=(a*(t.y-i.y)-r*(t.x-i.x))/(-a*s+o*r);return l>=0&&l<=1&&c>=0&&c<=1?{x:t.x+c*o,y:t.y+c*s}:null}function w(t){let e=0;for(let i=0;i<t.length;i++){const n=(i+1)%t.length;e+=t[i].x*t[n].y,e-=t[n].x*t[i].y}return Math.abs(e/2)}function S(t,e,i){let n=e.x-t.x,o=e.y-t.y,s=i.x-t.x;return n*(i.y-t.y)-o*s>0}function F(t,e){for(let i=0;i<4;i++)if(!S(t.points[i],t.points[(i+1)%4],e))return!1;return!0}"function"==typeof SuppressedError&&SuppressedError;const L=3,N=1,k=1,W=2,G=3,j=5,V=15,U=5;function P(t,e,i,n){const o=t.points,s=e.points;let a=8*i;a=Math.max(a,5);const r=B(o)[3],l=B(o)[1],c=B(s)[3],h=B(s)[1];let f,p=0;if(f=Math.max(Math.abs(R(r,e.points[0])),Math.abs(R(r,e.points[3]))),f>p&&(p=f),f=Math.max(Math.abs(R(l,e.points[1])),Math.abs(R(l,e.points[2]))),f>p&&(p=f),f=Math.max(Math.abs(R(c,t.points[0])),Math.abs(R(c,t.points[3]))),f>p&&(p=f),f=Math.max(Math.abs(R(h,t.points[1])),Math.abs(R(h,t.points[2]))),f>p&&(p=f),p>a)return!1;const u=M(B(o)[0]),g=M(B(o)[2]),d=M(B(s)[0]),m=M(B(s)[2]),y=O(u,m),x=O(d,g),v=y>x,E=Math.min(y,x),I=O(u,g),b=O(d,m);let T=12*i;T=Math.max(T,5),T=Math.min(T,I),T=Math.min(T,b);return!!(E<T||C(o,v?d:m)||C(s,v?g:u))&&(v?(n.points[0]=t.points[0],n.points[1]=t.points[1],n.points[2]=e.points[2],n.points[3]=e.points[3]):(n.points[0]=e.points[0],n.points[1]=e.points[1],n.points[2]=t.points[2],n.points[3]=t.points[3]),n.area=w(n.points),!0)}class Q{constructor(t,e,i,n){this.overlapCount=t,this.verificationCount=e,this.crossVerificationFrame=5,this.location=n.location,this.locationArea=n.location.area,this.locationAngle=n.angle,this.format=n.format,this.text=n.text,this.isOneD=i,this.item=n;this.locationThreshold=n.moduleSize*j,this.strictLimit=Math.max(this.locationThreshold,1),this.strictLimit=Math.min(this.strictLimit,15)}getCenterPoint(t){const e={x:0,y:0};return t.forEach((({x:t,y:i})=>{e.x+=t,e.y+=i})),e.x/=t.length,e.y/=t.length,e}isProbablySameLocationWithOffset(t,e){const i=this.item.location,n=t.location;if(i.area<=0)return!1;if(Math.abs(i.area-n.area)>.4*i.area)return!1;let o=new Array(4).fill(0),s=new Array(4).fill(0),a=0,r=0;for(let t=0;t<4;++t)o[t]=Math.round(100*(n.points[t].x-i.points[t].x))/100,a+=o[t],s[t]=Math.round(100*(n.points[t].y-i.points[t].y))/100,r+=s[t];a/=4,r/=4;for(let t=0;t<4;++t){if(Math.abs(o[t]-a)>this.strictLimit||Math.abs(a)>.8)return!1;if(Math.abs(s[t]-r)>this.strictLimit||Math.abs(r)>.8)return!1}return e.x=a,e.y=r,!0}isLocationOverlap(t,e){if(this.locationArea>e){for(let e=0;e<4;e++)if(F(this.location,t.points[e]))return!0;const e=this.getCenterPoint(t.points);if(F(this.location,e))return!0}else{for(let e=0;e<4;e++)if(F(t,this.location.points[e]))return!0;if(F(t,this.getCenterPoint(this.location.points)))return!0}return!1}isMatchedLocationWithOffset(t,e={x:0,y:0}){if(this.isOneD){const i=Object.assign({},t.location);for(let t=0;t<4;t++)i.points[t].x-=e.x,i.points[t].y-=e.y;if(!this.isLocationOverlap(i,t.locationArea))return!1;const n=[this.location.points[0],this.location.points[3]],o=[this.location.points[1],this.location.points[2]];for(let t=0;t<4;t++){const e=i.points[t],s=0===t||3===t?n:o;if(Math.abs(R(s,e))>this.locationThreshold)return!1}}else for(let i=0;i<4;i++){const n=t.location.points[i],o=this.location.points[i];if(!(Math.abs(o.x+e.x-n.x)<this.locationThreshold))return!1;if(Math.abs(o.y+e.y-n.y)>=this.locationThreshold)return!1}return!0}isOverlappedLocationWithOffset(t,e,i=!0){const n=Object.assign({},t.location);for(let t=0;t<4;t++)n.points[t].x-=e.x,n.points[t].y-=e.y;if(!this.isLocationOverlap(n,t.location.area))return!1;if(i){const t=.75;return A([...this.location.points],n.points)>this.locationArea*t}return!0}}const X={BF_ONED:BigInt(3147775),BF_GS1_DATABAR:BigInt(260096)},Z={barcode:2,text_line:4,detected_quad:8,normalized_image:16},q=t=>Object.values(Z).includes(t)||Z.hasOwnProperty(t),z=(t,e)=>"string"==typeof t?e[Z[t]]:e[t],$=(t,e,i)=>{"string"==typeof t?e[Z[t]]=i:e[t]=i},H=(t,e,i)=>{if(t.isResultCrossVerificationEnabled(i))for(let t=0;t<e.length;t++)e[t]&&e[t].type===i&&!e[t].verified&&(e[t].isFilter=!0);if(t.isResultDeduplicationEnabled(i))for(let t=0;t<e.length;t++)e[t]&&e[t].type===i&&e[t].duplicate&&(e[t].isFilter=!0)};class J{constructor(){this.verificationEnabled={[h.CRIT_BARCODE]:!1,[h.CRIT_TEXT_LINE]:!0,[h.CRIT_DETECTED_QUAD]:!0,[h.CRIT_NORMALIZED_IMAGE]:!1},this.duplicateFilterEnabled={[h.CRIT_BARCODE]:!1,[h.CRIT_TEXT_LINE]:!1,[h.CRIT_DETECTED_QUAD]:!1,[h.CRIT_NORMALIZED_IMAGE]:!1},this.duplicateForgetTime={[h.CRIT_BARCODE]:3e3,[h.CRIT_TEXT_LINE]:3e3,[h.CRIT_DETECTED_QUAD]:3e3,[h.CRIT_NORMALIZED_IMAGE]:3e3},this.latestOverlappingEnabled={[h.CRIT_BARCODE]:!1,[h.CRIT_TEXT_LINE]:!1,[h.CRIT_DETECTED_QUAD]:!1,[h.CRIT_NORMALIZED_IMAGE]:!1},this.maxOverlappingFrames={[h.CRIT_BARCODE]:5,[h.CRIT_TEXT_LINE]:5,[h.CRIT_DETECTED_QUAD]:5,[h.CRIT_NORMALIZED_IMAGE]:5},this.overlapSet=[],this.stabilityCount=0,this.crossVerificationFrames=5,E.set(this,new Map),I.set(this,new Map),b.set(this,new Map),T.set(this,new Map),_.set(this,new Map)}_dynamsoft(){v(this,E,"f").forEach(((t,e)=>{$(e,this.verificationEnabled,t)})),v(this,I,"f").forEach(((t,e)=>{$(e,this.duplicateFilterEnabled,t)})),v(this,b,"f").forEach(((t,e)=>{$(e,this.duplicateForgetTime,t)})),v(this,T,"f").forEach(((t,e)=>{$(e,this.latestOverlappingEnabled,t)})),v(this,_,"f").forEach(((t,e)=>{$(e,this.maxOverlappingFrames,t)}))}enableResultCrossVerification(t,e){q(t)&&v(this,E,"f").set(t,e)}isResultCrossVerificationEnabled(t){return!!q(t)&&z(t,this.verificationEnabled)}enableResultDeduplication(t,e){q(t)&&(e&&this.enableLatestOverlapping(t,!1),v(this,I,"f").set(t,e))}isResultDeduplicationEnabled(t){return!!q(t)&&z(t,this.duplicateFilterEnabled)}setDuplicateForgetTime(t,e){q(t)&&(e>18e4&&(e=18e4),e<0&&(e=0),v(this,b,"f").set(t,e))}getDuplicateForgetTime(t){return q(t)?z(t,this.duplicateForgetTime):-1}setMaxOverlappingFrames(t,e){q(t)&&v(this,_,"f").set(t,e)}getMaxOverlappingFrames(t){return q(t)?z(t,this.maxOverlappingFrames):-1}enableLatestOverlapping(t,e){q(t)&&(e&&this.enableResultDeduplication(t,!1),v(this,T,"f").set(t,e))}isLatestOverlappingEnabled(t){return!!q(t)&&z(t,this.latestOverlappingEnabled)}getFilteredResultItemTypes(){let t=0;const e=[h.CRIT_BARCODE,h.CRIT_TEXT_LINE,h.CRIT_DETECTED_QUAD,h.CRIT_NORMALIZED_IMAGE];for(let i=0;i<e.length;i++)(this.verificationEnabled[e[i]]||this.duplicateFilterEnabled[e[i]])&&(t|=e[i]);return t}onOriginalImageResultReceived(t){}latestOverlappingFilter(t){var e,i,n;const o=this.isResultCrossVerificationEnabled(h.CRIT_BARCODE),s=this.isLatestOverlappingEnabled(h.CRIT_BARCODE);if(o||s){const a=5,r=60,l=s?this.getMaxOverlappingFrames(h.CRIT_BARCODE):5,c=t.items.length,f=null===(n=null===(i=null===(e=null==t?void 0:t.intermediateResult)||void 0===e?void 0:e[0])||void 0===i?void 0:i.intermediateResultUnits)||void 0===n?void 0:n[1].localizedBarcodes,p=f.length;let u=[];const g=[],d={x:0,y:0};let m=new Array(c).fill(-1),y=0;const x=t.items.map((t=>{const e=(BigInt(t.format)&BigInt(X.BF_ONED))!=BigInt(0)||(BigInt(t.format)&BigInt(X.BF_GS1_DATABAR))!=BigInt(0);return new Q(l,e?1:2,e,t)}));if(this.overlapSet.length>0){const t=new Array(c).fill(new Array(this.overlapSet.length).fill(1));let e=0;for(;e<c;){const i={x:0,y:0},n=new Array(c).fill(-1);let o=!1;for(;e<c;e++){const s=x[e].item;for(let a=0;a<this.overlapSet.length;a++){if(t[e][a]<1)continue;const r=this.overlapSet[a],l=r.item;if(s.format===l.format&&s.text===l.text){if(o=r.isProbablySameLocationWithOffset(x[e],i),o){n[e]=a,t[e][a]=0;break}}else t[e][a]=0}if(o)break}if(o){for(let o=0;o<c;o++){if(o===e)continue;const s=x[o].item;for(let e=0;e<this.overlapSet.length;e++){if(t[o][e]<1)continue;if(n.includes(e))continue;const a=this.overlapSet[e],r=a.item;if(s.format===r.format&&s.text===r.text){if(a.isMatchedLocationWithOffset(x[o],i)){n[o]=e,t[o][e]=0;break}}else t[o][e]=0}}const o=n.filter((t=>-1!==t)).length;o>y&&(y=o,m=n,d.x=i.x,d.y=i.y)}}if(0===y){for(let e=0;e<c;e++){const i=x[e].item;for(let n=0;n<this.overlapSet.length;n++){if(t[e][n]<1)continue;if(m.includes(n))continue;const o=this.overlapSet[n],s=o.item;if(i.format===s.format&&i.text===s.text){if(o.isMatchedLocationWithOffset(x[e])){m[e]=n,t[e][n]=0;break}}else t[e][n]=0}}y+=m.filter((t=>-1!=t)).length}let i=this.overlapSet.length<=L?y>=N:y>=W;if(!i&&s&&p>0){let t=0;for(let e=0;e<this.overlapSet.length;e++){const i=this.overlapSet[e];for(let e=0;e<p;e++){if(i.isOverlappedLocationWithOffset(f[e],d)){t++;break}}}i=this.overlapSet.length<=L?t>=k:t>=G}i||(this.overlapSet=[])}if(0===this.overlapSet.length)this.stabilityCount=0,t.items.forEach(((t,e)=>{const i=Object.assign({},t),n=(BigInt(t.format)&BigInt(X.BF_ONED))!=BigInt(0)||(BigInt(t.format)&BigInt(X.BF_GS1_DATABAR))!=BigInt(0),s=t.confidence<r,a=new Q(l,n?1:2,n,i);o&&n&&s&&g.push(e),this.overlapSet.push(a)}));else{let e=!0;s?(Math.abs(d.x)>U||Math.abs(d.y)>U)&&(e=!1):e=!1;for(let i=0;i<t.items.length;i++){const t=m[i];if(t<0){const t=x[i].item;let n={points:[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],area:0};for(let i=0;i<4;i++)n.points[i].x=e?t.location.points[i].x-d.x:t.location.points[i].x,n.points[i].y=e?t.location.points[i].y-d.y:t.location.points[i].y;for(let o=0;o<this.overlapSet.length;o++){if(m.includes(o))continue;const s=this.overlapSet[o].item.text,a=this.overlapSet[o].item.format;if(t.format===a&&t.text===s){if(this.overlapSet[o].isOverlappedLocationWithOffset(t,d,!1)){const e=Object.assign({},t),n=(BigInt(e.format)&BigInt(X.BF_ONED))!=BigInt(0)||(BigInt(e.format)&BigInt(X.BF_GS1_DATABAR))!=BigInt(0),s=n?1:2;this.overlapSet[o]=new Q(l,s,n,e),m[i]=o;break}if(x[i].isOneD){let s={points:[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],area:0};for(let t=0;t<4;t++)s.points[t].x=e?this.overlapSet[o].location.points[t].x:this.overlapSet[o].location.points[t].x+d.x,s.points[t].y=e?this.overlapSet[o].location.points[t].y:this.overlapSet[o].location.points[t].y+d.y;let a={points:[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],area:0};if(P(n,s,t.moduleSize,a)){t.location=a;const e=Object.assign({},t),n=(BigInt(e.format)&BigInt(X.BF_ONED))!=BigInt(0)||(BigInt(e.format)&BigInt(X.BF_GS1_DATABAR))!=BigInt(0),s=n?1:2;this.overlapSet[o]=new Q(l,s,n,e),m[i]=o;break}}}}}else{if(e){x[i].item.location=this.overlapSet[t].location}else{const e=Object.assign({},x[i].item),n=(BigInt(e.format)&BigInt(X.BF_ONED))!=BigInt(0)||(BigInt(e.format)&BigInt(X.BF_GS1_DATABAR))!=BigInt(0),o=n?1:2;this.overlapSet[t]=new Q(l,o,n,e)}this.overlapSet[t].overlapCount=l,this.overlapSet[t].verificationCount=2,this.overlapSet[t].crossVerificationFrame=a}}e?this.stabilityCount<V&&this.stabilityCount++:this.stabilityCount=0;let i=!0;for(let t=0;t<this.overlapSet.length;t++){if(m.includes(t))continue;const n=this.overlapSet[t];n.overlapCount--,n.crossVerificationFrame--;const o=n.overlapCount+this.stabilityCount;if(s&&o>0){for(let t=0;t<c;t++){if(n.isOverlappedLocationWithOffset(x[t],d,!1)){i=!1;break}}if(!i)break;const t=n.item;if(!e){for(let t=0;t<4;t++)n.location.points[t].x+=d.x,n.location.points[t].y+=d.y;t.location=n.location}2===n.verificationCount&&u.push(t)}}if(s&&!i){u=[];for(let t=0;t<this.overlapSet.length;t++){if(m.includes(t))continue;const e=this.overlapSet[t];e.overlapCount=0-this.stabilityCount,e.crossVerificationFrame=0,e.verificationCount=0}}for(let t=0;t<c;t++){if(-1!==m[t])continue;const i=x[t].item;if(e){for(let e=0;e<4;e++)x[t].location.points[e].x-=d.x,x[t].location.points[e].y-=d.y;i.location=x[t].location}let n=!1;for(let e of this.overlapSet)if(!(e.crossVerificationFrame<=0&&e.verificationCount<=0)&&(n=e.isLocationOverlap(x[t].location,x[t].locationArea),n))break;if(n){g.push(t);continue}const s=Object.assign({},i),a=(BigInt(i.format)&BigInt(X.BF_ONED))!=BigInt(0)||(BigInt(i.format)&BigInt(X.BF_GS1_DATABAR))!=BigInt(0),c=i.confidence<r,h=new Q(l,a?1:2,a,s);o&&a&&c?g.push(t):h.verificationCount=2,this.overlapSet.push(h)}this.overlapSet=this.overlapSet.filter((t=>!(t.overlapCount+this.stabilityCount<=0&&t.crossVerificationFrame<=0)))}g.sort(((t,e)=>e-t)).forEach(((e,i)=>{t.items.splice(e,1)})),u.forEach((e=>{t.items.push(Object.assign(Object.assign({},e),{overlapped:!0}))}))}}onDecodedBarcodesReceived(t){H(this,t.items,h.CRIT_BARCODE)}onRecognizedTextLinesReceived(t){H(this,t.items,h.CRIT_TEXT_LINE)}onDetectedQuadsReceived(t){H(this,t.items,h.CRIT_DETECTED_QUAD)}onNormalizedImagesReceived(t){H(this,t.items,h.CRIT_NORMALIZED_IMAGE)}}E=new WeakMap,I=new WeakMap,b=new WeakMap,T=new WeakMap,_=new WeakMap;export{p as ImageManager,J as MultiFrameResultCrossFilter,x as UtilityModule};
